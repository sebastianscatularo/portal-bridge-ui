{"version":3,"file":"static/js/970.d7a8e1d2.chunk.js","mappings":"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","sources":["../node_modules/@ledgerhq/cryptoassets/src/data/evm/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/contracts.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/erc20.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/loadConfig.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/nfts.ts","../node_modules/@ledgerhq/hw-app-eth/src/utils.ts"],"sourcesContent":["import arbitrum_tokens from \"./42161/erc20.json\";\nimport arbitrum_goerli_tokens from \"./421613/erc20.json\";\nimport bsc_tokens from \"./56/erc20.json\";\nimport cronos_tokens from \"./25/erc20.json\";\nimport ethereum_tokens from \"./1/erc20.json\";\nimport ethereum_goerli_tokens from \"./5/erc20.json\";\nimport ethereum_rinkeby_tokens from \"./4/erc20.json\";\nimport ethereum_ropsten_tokens from \"./3/erc20.json\";\nimport ethereum_sepolia_tokens from \"./11155111/erc20.json\";\nimport fantom_tokens from \"./250/erc20.json\";\nimport flare_tokens from \"./14/erc20.json\";\nimport moonbeam_tokens from \"./1284/erc20.json\";\nimport optimism_tokens from \"./10/erc20.json\";\nimport optimism_goerli_tokens from \"./420/erc20.json\";\nimport polygon_tokens from \"./137/erc20.json\";\nimport songbird_tokens from \"./19/erc20.json\";\nimport arbitrum_signatures from \"./42161/erc20-signatures.json\";\nimport arbitrum_goerli_signatures from \"./421613/erc20-signatures.json\";\nimport bsc_signatures from \"./56/erc20-signatures.json\";\nimport cronos_signatures from \"./25/erc20-signatures.json\";\nimport ethereum_signatures from \"./1/erc20-signatures.json\";\nimport ethereum_goerli_signatures from \"./5/erc20-signatures.json\";\nimport ethereum_rinkeby_signatures from \"./4/erc20-signatures.json\";\nimport ethereum_ropsten_signatures from \"./3/erc20-signatures.json\";\nimport ethereum_sepolia_signatures from \"./11155111/erc20-signatures.json\";\nimport fantom_signatures from \"./250/erc20-signatures.json\";\nimport flare_signatures from \"./14/erc20-signatures.json\";\nimport moonbeam_signatures from \"./1284/erc20-signatures.json\";\nimport optimism_signatures from \"./10/erc20-signatures.json\";\nimport optimism_goerli_signatures from \"./420/erc20-signatures.json\";\nimport polygon_signatures from \"./137/erc20-signatures.json\";\nimport songbird_signatures from \"./19/erc20-signatures.json\";\n\nexport const tokens = {\n  42161: arbitrum_tokens,\n  421613: arbitrum_goerli_tokens,\n  56: bsc_tokens,\n  25: cronos_tokens,\n  1: ethereum_tokens,\n  5: ethereum_goerli_tokens,\n  4: ethereum_rinkeby_tokens,\n  3: ethereum_ropsten_tokens,\n  11155111: ethereum_sepolia_tokens,\n  250: fantom_tokens,\n  14: flare_tokens,\n  1284: moonbeam_tokens,\n  10: optimism_tokens,\n  420: optimism_goerli_tokens,\n  137: polygon_tokens,\n  19: songbird_tokens,\n};\n\nexport const signatures = {\n  42161: arbitrum_signatures,\n  421613: arbitrum_goerli_signatures,\n  56: bsc_signatures,\n  25: cronos_signatures,\n  1: ethereum_signatures,\n  5: ethereum_goerli_signatures,\n  4: ethereum_rinkeby_signatures,\n  3: ethereum_ropsten_signatures,\n  11155111: ethereum_sepolia_signatures,\n  250: fantom_signatures,\n  14: flare_signatures,\n  1284: moonbeam_signatures,\n  10: optimism_signatures,\n  420: optimism_goerli_signatures,\n  137: polygon_signatures,\n  19: songbird_signatures,\n};\n\nexport default {\n  tokens,\n  signatures,\n};\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype ContractMethod = {\n  payload: string;\n  signature: string;\n  plugin: string;\n  erc20OfInterest: string[];\n  abi: any;\n};\n\n/**\n * Retrieve the metadatas a given contract address and a method selector\n */\nexport const loadInfosForContractMethod = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<ContractMethod | undefined> => {\n  const { pluginBaseURL, extraPlugins } = getLoadConfig(userLoadConfig);\n\n  let data = {};\n\n  if (pluginBaseURL) {\n    const url = `${pluginBaseURL}/plugins/ethereum.json`;\n    data = await axios\n      .get(`${pluginBaseURL}/plugins/ethereum.json`)\n      .then((r) => r.data as any)\n      .catch((e) => {\n        log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n        return null;\n      });\n  }\n\n  if (extraPlugins) {\n    data = { ...data, ...extraPlugins };\n  }\n\n  if (!data) return;\n\n  const lcSelector = selector.toLowerCase();\n  const lcContractAddress = contractAddress.toLowerCase();\n\n  if (lcContractAddress in data) {\n    const contractSelectors = data[lcContractAddress];\n\n    if (lcSelector in contractSelectors) {\n      return {\n        payload: contractSelectors[lcSelector][\"serialized_data\"],\n        signature: contractSelectors[lcSelector][\"signature\"],\n        plugin: contractSelectors[lcSelector][\"plugin\"],\n        erc20OfInterest: contractSelectors[lcSelector][\"erc20OfInterest\"],\n        abi: contractSelectors[\"abi\"],\n      };\n    }\n  }\n};\n","import axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\nimport { signatures as signaturesByChainId } from \"@ledgerhq/cryptoassets/data/evm/index\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport { LoadConfig } from \"../types\";\n\nconst asContractAddress = (addr: string) => {\n  const a = addr.toLowerCase();\n  return a.startsWith(\"0x\") ? a : \"0x\" + a;\n};\n\nexport const findERC20SignaturesInfo = async (\n  userLoadConfig: LoadConfig,\n  chainId: number\n): Promise<string | null> => {\n  const { cryptoassetsBaseURL } = getLoadConfig(userLoadConfig);\n  if (!cryptoassetsBaseURL) return null;\n\n  const url = `${cryptoassetsBaseURL}/evm/${chainId}/erc20-signatures.json`;\n  const blob = await axios\n    .get<string>(url)\n    .then(({ data }) => {\n      if (!data || typeof data !== \"string\") {\n        throw new Error(\n          `ERC20 signatures for chainId ${chainId} file is malformed ${url}`\n        );\n      }\n      return data;\n    })\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n\n  return blob;\n};\n\n/**\n * Retrieve the token information by a given contract address if any\n */\nexport const byContractAddressAndChainId = (\n  contract: string,\n  chainId: number,\n  erc20SignaturesBlob?: string | null\n): ReturnType<API[\"byContractAndChainId\"]> => {\n  // If we are able to fetch data from s3 bucket that contains dynamic CAL\n  if (erc20SignaturesBlob) {\n    try {\n      return parse(erc20SignaturesBlob).byContractAndChainId(\n        asContractAddress(contract),\n        chainId\n      );\n    } catch (e) {\n      return get(chainId)?.byContractAndChainId(\n        asContractAddress(contract),\n        chainId\n      );\n    }\n  }\n\n  // the static fallback when dynamic cal is not provided\n  return get(chainId)?.byContractAndChainId(\n    asContractAddress(contract),\n    chainId\n  );\n};\n\nexport type TokenInfo = {\n  contractAddress: string;\n  ticker: string;\n  decimals: number;\n  chainId: number;\n  signature: Buffer;\n  data: Buffer;\n};\nexport type API = {\n  byContractAndChainId: (\n    addr: string,\n    id: number\n  ) => TokenInfo | null | undefined;\n  list: () => TokenInfo[];\n};\n\nconst parse = (erc20SignaturesBlob: string): API => {\n  const buf = Buffer.from(erc20SignaturesBlob, \"base64\");\n  const map = {};\n  const entries: TokenInfo[] = [];\n  let i = 0;\n\n  while (i < buf.length) {\n    const length = buf.readUInt32BE(i);\n    i += 4;\n    const item = buf.slice(i, i + length);\n    let j = 0;\n    const tickerLength = item.readUInt8(j);\n    j += 1;\n    const ticker = item.slice(j, j + tickerLength).toString(\"ascii\");\n    j += tickerLength;\n    const contractAddress = asContractAddress(\n      item.slice(j, j + 20).toString(\"hex\")\n    );\n    j += 20;\n    const decimals = item.readUInt32BE(j);\n    j += 4;\n    const chainId = item.readUInt32BE(j);\n    j += 4;\n    const signature = item.slice(j);\n    const entry: TokenInfo = {\n      ticker,\n      contractAddress,\n      decimals,\n      chainId,\n      signature,\n      data: item,\n    };\n    entries.push(entry);\n    map[String(chainId) + \":\" + contractAddress] = entry;\n    i += length;\n  }\n\n  return {\n    list: () => entries,\n    byContractAndChainId: (contractAddress, chainId) =>\n      map[String(chainId) + \":\" + contractAddress],\n  };\n};\n\n// this internal get() will lazy load and cache the data from the erc20 data blob\nconst get: (chainId: number) => API | null = (() => {\n  const cache: Record<number, API> = {};\n  return (chainId) => {\n    if (cache[chainId]) return cache[chainId];\n\n    const signatureBlob: string | undefined = signaturesByChainId[chainId];\n    if (!signatureBlob) return null;\n\n    const api = parse(signatureBlob);\n    cache[chainId] = api;\n    return api;\n  };\n})();\n","// This implements the resolution of a Transaction using Ledger's own API\nimport { log } from \"@ledgerhq/logs\";\nimport { Interface } from \"@ethersproject/abi\";\n\nimport {\n  LedgerEthTransactionResolution,\n  LedgerEthTransactionService,\n  LoadConfig,\n} from \"../types\";\nimport { loadInfosForContractMethod } from \"./contracts\";\nimport { byContractAddressAndChainId, findERC20SignaturesInfo } from \"./erc20\";\nimport { getNFTInfo, loadNftPlugin } from \"./nfts\";\nimport {\n  decodeTxInfo,\n  tokenSelectors,\n  nftSelectors,\n  mergeResolutions,\n} from \"../../utils\";\n\ntype potentialResolutions = {\n  token: boolean | undefined;\n  nft: boolean | undefined;\n  externalPlugins: boolean | undefined;\n};\n\n/**\n * @ignore for external documentation\n *\n * Providing additionnal data for some transactions (Token or NFT related) can enable clear signing\n * of initially impossible to decode data.\n * This method will add necessary APDUs to the resolution paramter in order to provide this data to the nano app\n */\nconst getAdditionalDataForContract = async (\n  contractAddress: string,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: potentialResolutions\n): Promise<Pick<LedgerEthTransactionResolution, \"nfts\" | \"erc20Tokens\">> => {\n  const resolution: Pick<\n    LedgerEthTransactionResolution,\n    \"nfts\" | \"erc20Tokens\"\n  > = {\n    nfts: [],\n    erc20Tokens: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftInfo = await getNFTInfo(\n      contractAddress,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (nftInfo) {\n      log(\n        \"ethereum\",\n        \"loaded nft info for \" +\n          nftInfo.contractAddress +\n          \" (\" +\n          nftInfo.collectionName +\n          \")\"\n      );\n      resolution.nfts.push(nftInfo.data);\n    } else {\n      log(\"ethereum\", \"couldn't load nft info for \" + contractAddress);\n    }\n  }\n\n  if (shouldResolve.token) {\n    const erc20SignaturesBlob = await findERC20SignaturesInfo(\n      loadConfig,\n      chainIdTruncated\n    );\n    const erc20Info = byContractAddressAndChainId(\n      contractAddress,\n      chainIdTruncated,\n      erc20SignaturesBlob\n    );\n\n    if (erc20Info) {\n      log(\n        \"ethereum\",\n        \"loaded erc20token info for \" +\n          erc20Info.contractAddress +\n          \" (\" +\n          erc20Info.ticker +\n          \")\"\n      );\n      resolution.erc20Tokens.push(erc20Info.data.toString(\"hex\"));\n    } else {\n      log(\"ethereum\", \"couldn't load erc20token info for \" + contractAddress);\n    }\n  }\n\n  return resolution;\n};\n\n/**\n * @ignore for external documentation\n *\n * Depending on the transaction, it might be necessary to load internal plugins in the nano app\n * in order to clear sign it.\n * This method will add necessary APDUs to the resolution parameter in order to load those internal plugins\n */\nconst loadNanoAppPlugins = async (\n  contractAddress: string,\n  selector: string,\n  decodedTx,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: potentialResolutions\n): Promise<LedgerEthTransactionResolution> => {\n  let resolution: LedgerEthTransactionResolution = {\n    externalPlugin: [],\n    plugin: [],\n    nfts: [],\n    erc20Tokens: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftPluginPayload = await loadNftPlugin(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (nftPluginPayload) {\n      resolution.plugin.push(nftPluginPayload);\n    } else {\n      log(\n        \"ethereum\",\n        \"no NFT plugin payload for selector \" +\n          selector +\n          \" and address \" +\n          contractAddress\n      );\n    }\n  }\n\n  if (shouldResolve.externalPlugins) {\n    const contractMethodInfos = await loadInfosForContractMethod(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (contractMethodInfos) {\n      const { plugin, payload, signature, erc20OfInterest, abi } =\n        contractMethodInfos;\n\n      if (plugin) {\n        log(\"ethereum\", \"found plugin for \" + selector);\n        resolution.externalPlugin.push({ payload, signature });\n      }\n\n      if (erc20OfInterest && erc20OfInterest.length && abi) {\n        const contract = new Interface(abi);\n        const args = contract.parseTransaction(decodedTx).args;\n\n        for (const path of erc20OfInterest) {\n          const erc20ContractAddress = path.split(\".\").reduce((value, seg) => {\n            if (seg === \"-1\" && Array.isArray(value)) {\n              return value[value.length - 1];\n            }\n            return value[seg];\n          }, args) as unknown as string; // impossible(?) to type correctly as the initializer is different from the returned type\n\n          const externalPluginResolution = await getAdditionalDataForContract(\n            erc20ContractAddress,\n            chainIdTruncated,\n            loadConfig,\n            {\n              nft: false,\n              externalPlugins: false,\n              token: true, // enforcing resolution of tokens for external plugins that need info on assets (e.g. for a swap)\n            }\n          );\n          resolution = mergeResolutions(resolution, externalPluginResolution);\n        }\n      }\n    } else {\n      log(\"ethereum\", \"no infos for selector \" + selector);\n    }\n  }\n\n  return resolution;\n};\n\nconst ledgerService: LedgerEthTransactionService = {\n  resolveTransaction: async (rawTxHex, loadConfig, resolutionConfig) => {\n    const rawTx = Buffer.from(rawTxHex, \"hex\");\n    const { decodedTx, chainIdTruncated } = decodeTxInfo(rawTx);\n\n    const contractAddress = decodedTx.to;\n    const selector =\n      decodedTx.data.length >= 10 && decodedTx.data.substring(0, 10);\n\n    let pluginsResolution: Partial<LedgerEthTransactionResolution> = {};\n    let contractResolution: Partial<LedgerEthTransactionResolution> = {};\n    if (selector) {\n      const shouldResolve: potentialResolutions = {\n        token: resolutionConfig.erc20 && tokenSelectors.includes(selector),\n        nft: resolutionConfig.nft && nftSelectors.includes(selector),\n        externalPlugins: resolutionConfig.externalPlugins,\n      };\n\n      pluginsResolution = await loadNanoAppPlugins(\n        contractAddress,\n        selector,\n        decodedTx,\n        chainIdTruncated,\n        loadConfig,\n        shouldResolve\n      );\n\n      contractResolution = await getAdditionalDataForContract(\n        contractAddress,\n        chainIdTruncated,\n        loadConfig,\n        shouldResolve\n      );\n    }\n\n    return mergeResolutions(pluginsResolution, contractResolution);\n  },\n};\n\nexport default ledgerService;\n","import type { LoadConfig } from \"../types\";\n\nconst defaultLoadConfig = {\n  nftExplorerBaseURL: \"https://nft.api.live.ledger.com/v1/ethereum\",\n  pluginBaseURL: \"https://cdn.live.ledger.com\",\n  extraPlugins: null,\n  cryptoassetsBaseURL: \"https://cdn.live.ledger.com/cryptoassets\",\n};\n\nexport function getLoadConfig(userLoadConfig?: LoadConfig): LoadConfig {\n  return {\n    ...defaultLoadConfig,\n    ...userLoadConfig,\n  };\n}\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype NftInfo = {\n  contractAddress: string;\n  collectionName: string;\n  data: string;\n};\n\ntype BackendResponse = {\n  payload: string;\n};\n\nexport const getNFTInfo = async (\n  contractAddress: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<NftInfo | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}`;\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then((r) => r.data)\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  // APDU response specification: https://ledgerhq.atlassian.net/wiki/spaces/WALLETCO/pages/3269984297/NFT-1+NFT+Backend+design#NFT-Metadata-BLOB\n  const payload = response[\"payload\"];\n  // Collection name length position: 3rd byte -> caracter 4 to 6\n  const collectionNameLength = parseInt(payload.slice(4, 6), 16);\n  const collectionNameHex = payload.substr(6, collectionNameLength * 2);\n  const collectionName = collectionNameHex\n    .match(/.{2}/g) // split every 2 characters\n    ?.reduce(\n      (acc, curr) => (acc += String.fromCharCode(parseInt(curr, 16))),\n      \"\"\n    ); // convert hex to string\n\n  return {\n    contractAddress: contractAddress,\n    collectionName: collectionName || \"\",\n    data: payload,\n  };\n};\n\nexport const loadNftPlugin = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<string | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}/plugin-selector/${selector}`;\n\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then((r) => r.data)\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  const payload = response[\"payload\"];\n  return payload;\n};\n","import { encode, decode } from \"@ethersproject/rlp\";\nimport { BigNumber } from \"bignumber.js\";\nimport { LedgerEthTransactionResolution } from \"./services/types\";\n\nexport function splitPath(path: string): number[] {\n  const result: number[] = [];\n  const components = path.split(\"/\");\n  components.forEach((element) => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\nexport function hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nexport function maybeHexBuffer(\n  str: string | null | undefined\n): Buffer | null | undefined {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nexport const decodeTxInfo = (rawTx: Buffer) => {\n  const VALID_TYPES = [1, 2];\n  const txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n  const rlpData = txType === null ? rawTx : rawTx.slice(1);\n  const rlpTx = decode(rlpData).map((hex) => Buffer.from(hex.slice(2), \"hex\"));\n  let chainIdTruncated = 0;\n  const rlpDecoded = decode(rlpData);\n\n  let decodedTx;\n  if (txType === 2) {\n    // EIP1559\n    decodedTx = {\n      data: rlpDecoded[7],\n      to: rlpDecoded[5],\n      chainId: rlpTx[0],\n    };\n  } else if (txType === 1) {\n    // EIP2930\n    decodedTx = {\n      data: rlpDecoded[6],\n      to: rlpDecoded[4],\n      chainId: rlpTx[0],\n    };\n  } else {\n    // Legacy tx\n    decodedTx = {\n      data: rlpDecoded[5],\n      to: rlpDecoded[3],\n      // Default to 1 for non EIP 155 txs\n      chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\"),\n    };\n  }\n\n  const chainIdSrc = decodedTx.chainId;\n  let chainId = new BigNumber(0);\n  if (chainIdSrc) {\n    // Using BigNumber because chainID could be any uint256.\n    chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n    const chainIdTruncatedBuf = Buffer.alloc(4);\n    if (chainIdSrc.length > 4) {\n      chainIdSrc.copy(chainIdTruncatedBuf);\n    } else {\n      chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n    }\n    chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n  }\n\n  let vrsOffset = 0;\n  if (txType === null && rlpTx.length > 6) {\n    const rlpVrs = Buffer.from(encode(rlpTx.slice(-3)).slice(2), \"hex\");\n\n    vrsOffset = rawTx.length - (rlpVrs.length - 1);\n\n    // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n    if (rlpVrs[0] > 0xf7) {\n      // Increment vrsOffset to account for that extra byte.\n      vrsOffset++;\n\n      // Compute size of the list length.\n      const sizeOfListLen = rlpVrs[0] - 0xf7;\n\n      // Increase rlpOffset by the size of the list length.\n      vrsOffset += sizeOfListLen - 1;\n    }\n  }\n\n  return {\n    decodedTx,\n    txType,\n    chainId,\n    chainIdTruncated,\n    vrsOffset,\n  };\n};\n\n/**\n * @ignore for the README\n *\n * Helper to convert an integer as a hexadecimal string with the right amount of digits\n * to respect the number of bytes given as parameter\n *\n * @param int Integer\n * @param bytes Number of bytes it should be represented as (1 byte = 2 caraters)\n * @returns The given integer as an hexa string padded with the right number of 0\n */\nexport const intAsHexBytes = (int: number, bytes: number): string =>\n  int.toString(16).padStart(2 * bytes, \"0\");\n\n/**\n * @ignore for the README\n *\n * List of selectors (hexadecimal representation of the used method's signature) related to\n * ERC20 (Tokens), ERC721/ERC1155 (NFT).\n * You can verify and/or get more info about them on http://4byte.directory\n */\n\nexport enum ERC20_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  TRANSFER = \"0xa9059cbb\",\n}\n\nexport enum ERC721_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  TRANSFER_FROM = \"0x23b872dd\",\n  SAFE_TRANSFER_FROM = \"0x42842e0e\",\n  SAFE_TRANSFER_FROM_WITH_DATA = \"0xb88d4fde\",\n}\n\nexport enum ERC1155_CLEAR_SIGNED_SELECTORS {\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  SAFE_TRANSFER_FROM = \"0xf242432a\",\n  SAFE_BATCH_TRANSFER_FROM = \"0x2eb2c2d6\",\n}\n\nexport const tokenSelectors = Object.values(ERC20_CLEAR_SIGNED_SELECTORS);\nexport const nftSelectors = [\n  ...Object.values(ERC721_CLEAR_SIGNED_SELECTORS),\n  ...Object.values(ERC1155_CLEAR_SIGNED_SELECTORS),\n];\n\nexport const mergeResolutions = (\n  oldResolution: Partial<LedgerEthTransactionResolution>,\n  newResolution: Partial<LedgerEthTransactionResolution>\n): LedgerEthTransactionResolution => {\n  const resolutions: LedgerEthTransactionResolution = {\n    nfts: [],\n    erc20Tokens: [],\n    externalPlugin: [],\n    plugin: [],\n  };\n\n  for (const key in oldResolution) {\n    resolutions[key].push(...oldResolution[key]);\n  }\n\n  for (const key in newResolution) {\n    resolutions[key].push(...newResolution[key]);\n  }\n\n  return resolutions;\n};\n"],"names":["erc20_json_1","__importDefault","require","erc20_json_2","erc20_json_3","erc20_json_4","erc20_json_5","erc20_json_6","erc20_json_7","erc20_json_8","erc20_json_9","erc20_json_10","erc20_json_11","erc20_json_12","erc20_json_13","erc20_json_14","erc20_json_15","erc20_json_16","erc20_signatures_json_1","erc20_signatures_json_2","erc20_signatures_json_3","erc20_signatures_json_4","erc20_signatures_json_5","erc20_signatures_json_6","erc20_signatures_json_7","erc20_signatures_json_8","erc20_signatures_json_9","erc20_signatures_json_10","erc20_signatures_json_11","erc20_signatures_json_12","erc20_signatures_json_13","erc20_signatures_json_14","erc20_signatures_json_15","erc20_signatures_json_16","exports","tokens","signatures","axios_1","loadConfig_1","logs_1","contractAddress","selector","chainId","userLoadConfig","__awaiter","_a","getLoadConfig","pluginBaseURL","extraPlugins","data","url_1","concat","get","then","r","e","log","String","_b","sent","__assign","lcSelector","toLowerCase","lcContractAddress","contractSelectors","payload","signature","plugin","erc20OfInterest","abi","index_1","asContractAddress","addr","a","startsWith","cryptoassetsBaseURL","url","Error","contract","erc20SignaturesBlob","parse","byContractAndChainId","buf","Buffer","from","map","entries","i","length","length_1","readUInt32BE","item","slice","j","tickerLength","readUInt8","ticker","toString","decimals","entry","push","list","cache","signatureBlob","api","abi_1","contracts_1","erc20_1","nfts_1","utils_1","getAdditionalDataForContract","chainIdTruncated","loadConfig","shouldResolve","resolution","nfts","erc20Tokens","nft","getNFTInfo","nftInfo","collectionName","token","findERC20SignaturesInfo","erc20Info","byContractAddressAndChainId","loadNanoAppPlugins","decodedTx","externalPlugin","loadNftPlugin","nftPluginPayload","externalPlugins","loadInfosForContractMethod","contractMethodInfos","Interface","args","parseTransaction","erc20OfInterest_1","__values","erc20OfInterest_1_1","next","path","value","erc20ContractAddress","split","reduce","seg","Array","isArray","externalPluginResolution","mergeResolutions","ledgerService","resolveTransaction","rawTxHex","resolutionConfig","rawTx","decodeTxInfo","to","substring","pluginsResolution","contractResolution","erc20","tokenSelectors","includes","nftSelectors","defaultLoadConfig","nftExplorerBaseURL","response","collectionNameLength","parseInt","collectionNameHex","substr","match","acc","curr","fromCharCode","rlp_1","bignumber_js_1","hexBuffer","str","result","forEach","element","number","isNaN","txType","rlpData","rlpTx","decode","hex","rlpDecoded","chainIdSrc","BigNumber","chainIdTruncatedBuf","alloc","copy","vrsOffset","rlpVrs","encode","ERC20_CLEAR_SIGNED_SELECTORS","ERC721_CLEAR_SIGNED_SELECTORS","ERC1155_CLEAR_SIGNED_SELECTORS","int","bytes","padStart","Object","values","__spreadArray","__read","oldResolution","newResolution","resolutions","key","apply"],"sourceRoot":""}